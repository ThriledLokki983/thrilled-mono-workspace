import express from 'express';
import { Redis } from 'ioredis';
import { Logger } from '@mono/be-core';
import {
  JWTProvider,
  PasswordManager,
  SessionManager,
  AuthMiddleware,
  RBACManager,
  AuthConfig,
  ValidationUtils,
  CryptoUtils,
  RedisCacheAdapter
} from '../index.js';

// Example Express app demonstrating the authentication package
export class AuthExample {
  private app: express.Application;
  private redis: Redis;
  private logger: Logger;
  private jwtProvider!: JWTProvider;
  private passwordManager!: PasswordManager;
  private sessionManager!: SessionManager;
  private authMiddleware!: AuthMiddleware;
  private rbacManager!: RBACManager;

  constructor() {
    this.app = express();
    this.redis = new (require('ioredis'))({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD
    });
    this.logger = new Logger({ level: 'info', dir: './logs/auth-example' });
    
    this.setupComponents();
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupComponents(): void {
    // Configuration
    const config: AuthConfig = {
      jwt: {
        accessToken: {
          secret: process.env.JWT_ACCESS_SECRET || 'your-access-secret',
          expiresIn: '15m',
          algorithm: 'HS256'
        },
        refreshToken: {
          secret: process.env.JWT_REFRESH_SECRET || 'your-refresh-secret',
          expiresIn: '7d',
          algorithm: 'HS256'
        }
      },
      password: {
        saltRounds: 12,
        minLength: 8,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSymbols: false,
        requireSpecialChars: true,
        maxAttempts: 5,
        lockoutDuration: '15m'
      },
      session: {
        defaultTTL: '24h',
        prefix: 'sess:',
        ttl: 86400, // 24 hours in seconds
        rolling: true,
        enableRollingSession: true,
        maxSessionsPerUser: 5,
        trackDevices: true,
        enableEventLogging: true
      },
      rbac: {
        enableRoleHierarchy: true,
        defaultRole: 'user',
        maxRolesPerUser: 10
      }
    };

    // Initialize components with cache adapter
    const cacheAdapter = new RedisCacheAdapter(this.redis);
    
    this.jwtProvider = new JWTProvider(this.redis, config.jwt, this.logger);
    this.passwordManager = new PasswordManager(config.password, cacheAdapter, this.logger);
    this.sessionManager = new SessionManager(config.session, cacheAdapter, this.logger);
    this.rbacManager = new RBACManager(this.redis, config.rbac, this.logger);
    this.authMiddleware = new AuthMiddleware(
      this.jwtProvider,
      this.sessionManager,
      config,
      this.logger
    );
  }

  private setupMiddleware(): void {
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));
    
    // CORS middleware
    this.app.use((req, res, next) => {
      res.header('Access-Control-Allow-Origin', '*');
      res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      next();
    });
  }

  private setupRoutes(): void {
    // Public routes
    this.app.post('/api/auth/register', this.handleRegister.bind(this));
    this.app.post('/api/auth/login', this.handleLogin.bind(this));
    this.app.post('/api/auth/refresh', this.handleRefreshToken.bind(this));
    this.app.post('/api/auth/forgot-password', this.handleForgotPassword.bind(this));
    this.app.post('/api/auth/reset-password', this.handleResetPassword.bind(this));

    // Protected routes
    this.app.use('/api/protected', this.authMiddleware.requireAuth());
    this.app.get('/api/protected/profile', this.handleGetProfile.bind(this));
    this.app.put('/api/protected/profile', this.handleUpdateProfile.bind(this));
    this.app.post('/api/protected/change-password', this.handleChangePassword.bind(this));
    this.app.post('/api/protected/logout', this.handleLogout.bind(this));
    this.app.get('/api/protected/sessions', this.handleGetSessions.bind(this));
    this.app.delete('/api/protected/sessions/:sessionId', this.handleDestroySession.bind(this));

    // Admin routes
    this.app.use('/api/admin', this.authMiddleware.requireAdmin());
    this.app.get('/api/admin/users', this.handleGetUsers.bind(this));
    this.app.post('/api/admin/users/:userId/roles', this.handleAssignRole.bind(this));
    this.app.delete('/api/admin/users/:userId/roles/:roleName', this.handleRemoveRole.bind(this));

    // Moderator routes
    this.app.use('/api/moderator', this.authMiddleware.requireModerator());
    this.app.get('/api/moderator/reports', this.handleGetReports.bind(this));

    // Permission-based routes
    this.app.get('/api/content', 
      this.authMiddleware.requirePermissions(['content.read']),
      this.handleGetContent.bind(this)
    );
    
    this.app.post('/api/content', 
      this.authMiddleware.requirePermissions(['content.write']),
      this.handleCreateContent.bind(this)
    );

    // Rate limited routes
    this.app.post('/api/auth/login',
      this.authMiddleware.rateLimit(5, 15 * 60 * 1000), // 5 attempts per 15 minutes
      this.handleLogin.bind(this)
    );

    // Custom authorization example
    this.app.get('/api/users/:userId/data',
      this.authMiddleware.requireAuth(),
      this.authMiddleware.authorize(async (authContext, req) => {
        // Users can only access their own data, unless they're admin
        const requestedUserId = req.params.userId;
        return authContext.userId === requestedUserId || 
               authContext.roles.includes('admin');
      }),
      this.handleGetUserData.bind(this)
    );
  }

  // Route handlers
  private async handleRegister(req: express.Request, res: express.Response): Promise<void> {
    try {
      const { email, password, username } = req.body;

      // Validate input
      if (!ValidationUtils.isValidEmail(email)) {
        res.status(400).json({ error: 'Invalid email format' });
        return;
      }

      if (!ValidationUtils.isValidUsername(username)) {
        res.status(400).json({ error: 'Invalid username format' });
        return;
      }

      const passwordValidation = ValidationUtils.validatePasswordStrength(password);
      if (!passwordValidation.isValid) {
        res.status(400).json({ 
          error: 'Password does not meet requirements',
          feedback: passwordValidation.feedback
        });
        return;
      }

      // Hash password
      const hashedPassword = await this.passwordManager.hashPassword(password);

      // Create user (this would typically involve your user database)
      const userId = CryptoUtils.generateToken({ length: 16 });
      
      // Assign default role
      await this.rbacManager.assignRoleToUser(userId, 'user');

      res.status(201).json({ 
        message: 'User registered successfully',
        userId 
      });
    } catch (error) {
      this.logger.error('Registration error:', error);
      res.status(500).json({ error: 'Registration failed' });
    }
  }

  private async handleLogin(req: express.Request, res: express.Response): Promise<void> {
    try {
      const { email, password } = req.body;
      const userAgent = req.get('user-agent') || '';
      const ipAddress = req.ip || '';

      // Find user by email (mock implementation)
      const user = await this.findUserByEmail(email);
      if (!user) {
        res.status(401).json({ error: 'Invalid credentials' });
        return;
      }

      // Verify password
      const isValidPassword = await this.passwordManager.verifyPassword(password, user.hashedPassword);
      if (!isValidPassword) {
        res.status(401).json({ error: 'Invalid credentials' });
        return;
      }

      // Get user roles and permissions
      const roles = await this.rbacManager.getUserRoles(user.id);
      const permissions = await this.rbacManager.getUserPermissions(user.id);

      // Create session
      const sessionData = {
        userId: user.id,
        userAgent,
        ipAddress,
        deviceInfo: {
          userAgent,
          ipAddress
        }
      };

      const session = await this.sessionManager.createSession(sessionData);

      // Create tokens
      const accessToken = await this.jwtProvider.createAccessToken({
        userId: user.id,
        sessionId: session.id,
        roles,
        permissions,
        userData: {
          email: user.email,
          username: user.username
        }
      });

      const refreshToken = await this.jwtProvider.createRefreshToken(user.id, session.id);

      res.json({
        accessToken,
        refreshToken,
        user: {
          id: user.id,
          email: user.email,
          username: user.username,
          roles,
          permissions
        },
        session: {
          id: session.id,
          expiresAt: session.expiresAt
        }
      });
    } catch (error) {
      this.logger.error('Login error:', error);
      res.status(500).json({ error: 'Login failed' });
    }
  }

  private async handleRefreshToken(req: express.Request, res: express.Response): Promise<void> {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        res.status(400).json({ error: 'Refresh token required' });
        return;
      }

      // Verify refresh token
      const tokenData = await this.jwtProvider.verifyRefreshToken(refreshToken);
      if (!tokenData) {
        res.status(401).json({ error: 'Invalid refresh token' });
        return;
      }

      // Get updated user data
      const user = await this.findUserById(tokenData.userId);
      if (!user) {
        res.status(401).json({ error: 'User not found' });
        return;
      }

      const roles = await this.rbacManager.getUserRoles(user.id);
      const permissions = await this.rbacManager.getUserPermissions(user.id);

      // Refresh tokens
      const tokens = await this.jwtProvider.refreshTokens(refreshToken, {
        userData: {
          email: user.email,
          username: user.username
        },
        roles,
        permissions
      });

      res.json(tokens);
    } catch (error) {
      this.logger.error('Token refresh error:', error);
      res.status(500).json({ error: 'Token refresh failed' });
    }
  }

  private async handleForgotPassword(req: express.Request, res: express.Response): Promise<void> {
    try {
      const { email } = req.body;

      if (!ValidationUtils.isValidEmail(email)) {
        res.status(400).json({ error: 'Invalid email format' });
        return;
      }

      const user = await this.findUserByEmail(email);
      if (!user) {
        // Don't reveal if user exists
        res.json({ message: 'If the email exists, a reset link has been sent' });
        return;
      }

      const resetToken = await this.passwordManager.createResetToken(user.id);
      
      // Send reset email (mock implementation)
      await this.sendPasswordResetEmail(user.email, resetToken);

      res.json({ message: 'If the email exists, a reset link has been sent' });
    } catch (error) {
      this.logger.error('Forgot password error:', error);
      res.status(500).json({ error: 'Failed to process password reset request' });
    }
  }

  private async handleResetPassword(req: express.Request, res: express.Response): Promise<void> {
    try {
      const { token, newPassword } = req.body;

      // Validate new password
      const passwordValidation = ValidationUtils.validatePasswordStrength(newPassword);
      if (!passwordValidation.isValid) {
        res.status(400).json({ 
          error: 'Password does not meet requirements',
          feedback: passwordValidation.feedback
        });
        return;
      }

      // Verify reset token
      const userId = await this.passwordManager.verifyResetToken(token);
      if (!userId) {
        res.status(400).json({ error: 'Invalid or expired reset token' });
        return;
      }

      // Hash new password
      const hashedPassword = await this.passwordManager.hashPassword(newPassword);

      // Update user password (mock implementation)
      await this.updateUserPassword(userId, hashedPassword);

      // Blacklist all user tokens for security
      await this.jwtProvider.blacklistUserTokens(userId);
      await this.jwtProvider.revokeAllRefreshTokens(userId);

      res.json({ message: 'Password reset successfully' });
    } catch (error) {
      this.logger.error('Reset password error:', error);
      res.status(500).json({ error: 'Password reset failed' });
    }
  }

  private async handleGetProfile(req: express.Request & any, res: express.Response): Promise<void> {
    try {
      const user = await this.findUserById(req.auth.userId);
      if (!user) {
        res.status(404).json({ error: 'User not found' });
        return;
      }

      res.json({
        id: user.id,
        email: user.email,
        username: user.username,
        roles: req.auth.roles,
        permissions: req.auth.permissions
      });
    } catch (error) {
      this.logger.error('Get profile error:', error);
      res.status(500).json({ error: 'Failed to get profile' });
    }
  }

  private async handleLogout(req: express.Request & any, res: express.Response): Promise<void> {
    try {
      const authHeader = req.headers.authorization;
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.substring(7);
        await this.jwtProvider.blacklistToken(token);
      }

      if (req.auth.sessionId) {
        await this.sessionManager.destroySession(req.auth.sessionId);
      }

      res.json({ message: 'Logged out successfully' });
    } catch (error) {
      this.logger.error('Logout error:', error);
      res.status(500).json({ error: 'Logout failed' });
    }
  }

  private async handleGetSessions(req: express.Request & any, res: express.Response): Promise<void> {
    try {
      const sessions = await this.sessionManager.getUserSessions(req.auth.userId);
      res.json({ sessions });
    } catch (error) {
      this.logger.error('Get sessions error:', error);
      res.status(500).json({ error: 'Failed to get sessions' });
    }
  }

  private async handleAssignRole(req: express.Request, res: express.Response): Promise<void> {
    try {
      const { userId } = req.params;
      const { roleName } = req.body;

      await this.rbacManager.assignRoleToUser(userId, roleName);
      res.json({ message: 'Role assigned successfully' });
    } catch (error) {
      this.logger.error('Assign role error:', error);
      res.status(500).json({ error: 'Failed to assign role' });
    }
  }

  // Mock database methods (replace with actual database implementation)
  private async findUserByEmail(email: string): Promise<any> {
    // Mock implementation
    return {
      id: 'user123',
      email: email,
      username: 'testuser',
      hashedPassword: 'hashed_password_here'
    };
  }

  private async findUserById(userId: string): Promise<any> {
    // Mock implementation
    return {
      id: userId,
      email: 'test@example.com',
      username: 'testuser'
    };
  }

  private async sendPasswordResetEmail(email: string, token: string): Promise<void> {
    // Mock implementation
    this.logger.info(`Sending password reset email to ${email} with token ${token}`);
  }

  private async updateUserPassword(userId: string, hashedPassword: string): Promise<void> {
    // Mock implementation
    this.logger.info(`Updating password for user ${userId}`);
  }

  // Additional handler implementations...
  private async handleUpdateProfile(req: express.Request & any, res: express.Response): Promise<void> {
    res.json({ message: 'Profile updated' });
  }

  private async handleChangePassword(req: express.Request & any, res: express.Response): Promise<void> {
    res.json({ message: 'Password changed' });
  }

  private async handleDestroySession(req: express.Request & any, res: express.Response): Promise<void> {
    res.json({ message: 'Session destroyed' });
  }

  private async handleGetUsers(req: express.Request, res: express.Response): Promise<void> {
    res.json({ users: [] });
  }

  private async handleRemoveRole(req: express.Request, res: express.Response): Promise<void> {
    res.json({ message: 'Role removed' });
  }

  private async handleGetReports(req: express.Request, res: express.Response): Promise<void> {
    res.json({ reports: [] });
  }

  private async handleGetContent(req: express.Request, res: express.Response): Promise<void> {
    res.json({ content: [] });
  }

  private async handleCreateContent(req: express.Request, res: express.Response): Promise<void> {
    res.json({ message: 'Content created' });
  }

  private async handleGetUserData(req: express.Request, res: express.Response): Promise<void> {
    res.json({ data: {} });
  }

  public getApp(): express.Application {
    return this.app;
  }

  public async start(port: number = 3000): Promise<void> {
    // Initialize RBAC with default roles
    await this.rbacManager.initializeDefaultRoles();

    this.app.listen(port, () => {
      this.logger.info(`Auth example server running on port ${port}`);
    });
  }
}

// Usage
if (require.main === module) {
  const authExample = new AuthExample();
  authExample.start(3000).catch(console.error);
}
